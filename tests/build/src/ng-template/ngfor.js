"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var abstract_directive_1 = require("./abstract-directive");
var exception_1 = require("./exception");
var constants_1 = require("./constants");
var tokenizer_1 = require("./expression/tokenizer");
var exception_2 = require("./expression/exception");
var DATA_ID_KEY = "id";
var counter = 0;
// <div data-ng:for="let hero of data.heroes" data-ng:text="hero" ></div>
var NgFor = (function (_super) {
    __extends(NgFor, _super);
    function NgFor(el, reporter) {
        var _this = this;
        _super.call(this, el, reporter);
        this.nodes = this.initNodes(el, "ng-for", function (node, expr, compile, cache) {
            var parsed = _this.parseExpr(expr), outerHTML, id = "id" + (++counter);
            node.dataset["ngForScope"] = id;
            outerHTML = node.outerHTML;
            // Do not process directives on the first level as all of them about elements generated by ngFor
            ["ngSwitch", "ngSwitchCase", "ngSwitchCaseDefault", "ngIf",
                "ngClass", "ngData", "ngProp", "ngAttr", "ngEl", "ngText"].forEach(function (key) {
                if (node.dataset[key]) {
                    delete node.dataset[key];
                }
            });
            return {
                el: node,
                parentNode: node.parentNode,
                outerHTML: outerHTML,
                id: id,
                indexable: false,
                variable: parsed.variable,
                items: [],
                cache: cache,
                exp: function (data, cb) {
                    var it = [];
                    try {
                        it = tokenizer_1.ReferenceToken.findValue(parsed.iterable, data);
                    }
                    catch (err) {
                        if (!(err instanceof exception_2.ExpressionException)) {
                            throw new exception_1.Exception("Invalid ng* expression " + expr);
                        }
                        reporter.addLog((constants_1.ERROR_CODES.NGT0003 + ": ") + err.message);
                    }
                    if (!Array.isArray(it)) {
                        it = [];
                    }
                    return it;
                }
            };
        });
    }
    NgFor.prototype.parseExpr = function (strRaw) {
        var re = /(let|var)\s+([a-zA-Z0-9\_]+)\s+of\s+/, str = strRaw.trim(), varMatches = str.match(re);
        if (!varMatches || varMatches.length !== 3) {
            throw new exception_1.Exception("Cannot parse ng-for expression: " + strRaw);
        }
        return {
            variable: varMatches[2],
            iterable: str.replace(re, "")
        };
    };
    /**
     * Create for generated list elements a permitted parent elements
     */
    NgFor.createParentEl = function (tag) {
        var map = {
            "TR": "tbody",
            "THEAD": "table",
            "TFOOT": "table",
            "TBODY": "table",
            "COLGROUP": "table",
            "CAPTION": "table",
            "TD": "tr",
            "TH": "tr",
            "COL": "colgroup",
            "FIGCAPTION": "figure",
            "LEGEND": "fieldset",
            "LI": "ul",
            "DT": "dl",
            "DD": "dl",
        };
        var child = tag.toUpperCase(), parent = child in map ? map[child] : "div";
        return document.createElement(parent);
    };
    NgFor.prototype.removeIndexable = function (node, it) {
        return node.items.filter(function (instance) {
            return it.find(function (val) {
                return instance.id === val[DATA_ID_KEY];
            });
        });
    };
    NgFor.prototype.sync = function (data, Ctor) {
        var _this = this;
        this.nodes.forEach(function (node) {
            var it = node.exp(data);
            if (node.cache.match(JSON.stringify(it))) {
                return false;
            }
            // reduce: collection changed, it's a special case
            // if we have indexes (id) then we go still gacefully, we remove  particular nodes from the list
            // if not, we updateth list
            if (node.items.length > it.length) {
                node.items = node.indexable ? _this.removeIndexable(node, it) : [];
            }
            // expand: update every item and add new ones
            if (node.items.length < it.length) {
                var num = it.length - node.items.length;
                while (num--) {
                    var el = NgFor.createEl(node.el.tagName, node.outerHTML);
                    node.items.push(new Ctor(el));
                }
            }
            // sync
            it.forEach(function (val, inx) {
                var item = node.items[inx];
                data[node.variable] = val;
                item.sync(data);
                if (val && typeof val === "object" && DATA_ID_KEY in val) {
                    item.id = val[DATA_ID_KEY];
                    node.indexable = true;
                }
            });
            _this.buildDOM(node);
        });
    };
    NgFor.createEl = function (tag, html) {
        var parent = NgFor.createParentEl(tag);
        parent.innerHTML = html;
        return parent.firstElementChild;
    };
    NgFor.prototype.buildDOM = function (node) {
        var items = Array.from(node.parentNode.querySelectorAll("[data-ng-for-scope=\"" + node.id + "\"]")), anchor = document.createElement("ng");
        node.parentNode.insertBefore(anchor, items[0]);
        anchor.dataset["ngForScope"] = node.id;
        items.forEach(function (child) {
            node.parentNode.removeChild(child);
        });
        node.items.forEach(function (item) {
            node.parentNode.insertBefore(item.el, anchor);
        });
        node.parentNode.removeChild(anchor);
    };
    return NgFor;
}(abstract_directive_1.AbstractDirective));
exports.NgFor = NgFor;
